<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>MicroDexed web remote</title>
    <style>
		body {
			background: black;
			color: white;
			margin: 1rem;
		}
		canvas {
			margin-top: 2rem;
    		padding: 7px;
    		border-radius: 2px;
			/* box-shadow: 0 0 0px 5px #315b6a; */
			border: 1px solid #315b6a;
		}
		button {
			padding: 6px 8px;
    		border-radius: 2px;
    		border: none;
    		font-size: 1rem;
		} 
		button:hover {
			background: #bbb;
			cursor: pointer;
		}
    </style>
    <script src="https://cdn.jsdelivr.net/npm/webmidi@next/dist/iife/webmidi.iife.js"></script>
</head>
  <body>
    <div class=container>
      	<h1>MicroDexed web remote</h1>

		<div>
			<button id=btnConnection>&#128269; Open connection</button>
			<button id=btnSnapshot>&#x1F4F7; Capture image</button>
			<button id=btnRecord>&#128308; Record video</button>
			<button id=btnRecordAudio>&#127908; Record audio</button>
		</div>
		<canvas width=320 height=240></canvas>
		<hr>
		<h4>MD remote</h4>
		<div>
			<button id=btnSequencer>Start sequencer</button>
			<button id=btnAudio>Start audio</button>
		</div>
    </div>

	<script>
const canvas = document.querySelector('canvas');
const btnConnection = document.querySelector('#btnConnection');
const btnRecord = document.querySelector('#btnRecord');

let col, r, g, b;
let c;
let bgcolor;
let _buffer = new Uint8Array(512);
let _i = 0;
let _frameLength = -1;
let stateConnected = false;
let streamAudio;

// init display
let ctxVideo = canvas.getContext('2d');
ctxVideo.beginPath();
clear();

if ("serial" in navigator) {
	// The Web Serial API is supported.		
	let reader;
	let closedPromise;
	let keepReading = true;

	btnConnection.addEventListener('click', async () => {
		if (!stateConnected) {
			stateConnected = 1;
			btnConnection.innerHTML = '&#128473; Close';
			keepReading = true;

			// Filter on Teensy 4.1 devices with the USB Vendor/Product IDs.
			const filters = [{ usbVendorId: 0x16c0, usbProductId: 0x048a}];

			// Prompt user to select a Teensy device.
			const port = await navigator.serial.requestPort({ filters });

			// Wait for the serial port to open.
			await port.open({ 
				baudRate: 230400,
				// dataBits: 8,
				// stopBits: 1,
				// parity: 'none',
				// bufferSize: 512
				flowControlOptional: "hardware"
			});

			// init data process
			_buffer = new Uint8Array(512);
			_i = 0;
			_frameLength = -1;

			async function readUntilClosed() {
				while (port.readable && keepReading) {
					reader = port.readable.getReader();

					try {
						// Listen to data coming from the serial device.					
						while (true) {
							const { value, done } = await reader.read();
							if (done) {
								// reader.cancel() has been called.
								break;
							}
							// value is a Uint8Array.
							process(value);
						}
					} catch (error) {
						// Handle error...
					} finally {
						// Allow the serial port to be closed later.
						reader.releaseLock();
					}
				}

				await port.close();
			}

			closedPromise = readUntilClosed();
		} else {
			// User clicked a button to close the serial port.
			stateConnected = 0;
			btnConnection.innerHTML = '&#128269; Open connection';
			keepReading = false;
			// Force reader.read() to resolve immediately and subsequently
			// call reader.releaseLock() in the loop example above.
			reader.cancel();
			await closedPromise;
			clear();
		}
	});

	// document.querySelector('#btnClose').addEventListener('click', async () => {
	// 	// User clicked a button to close the serial port.
	// 	keepReading = false;
	// 	// Force reader.read() to resolve immediately and subsequently
	// 	// call reader.releaseLock() in the loop example above.
	// 	reader.cancel();
	// 	await closedPromise;
	// 	clear();
	// });

	// photo capture
	document.querySelector('#btnSnapshot').addEventListener('click', async () => {
    	const createEl = document.createElement('a');
    	createEl.href = canvas.toDataURL();
    	createEl.download = "md-screenshot";
    	createEl.click();
    	createEl.remove();
	});

	// video capture
	let recording = false;
	let mediaRecorder;
	let recordedChunks;
	let combined;

	btnRecord.addEventListener("click", () => {
		recording = !recording;
		if(recording) {
			btnRecord.innerHTML = "&#11035; Stop";
			const streamVideo = canvas.captureStream(30);

			if (streamAudio) {
				combined = new MediaStream([...streamVideo.getTracks(), ...streamAudio.getTracks()]);
			} else {
				combined = streamVideo;
			}

			// mediaRecorder = new MediaRecorder(streamVideo/*, {
			mediaRecorder = new MediaRecorder(combined, {
				mimeType: 'video/webm;codecs=vp9',
				ignoreMutedMedia: true
			});
			recordedChunks = [];
			mediaRecorder.ondataavailable = e => {
				if(e.data.size > 0){
					recordedChunks.push(e.data);
				}
			};
			mediaRecorder.start();
		} else {
			btnRecord.innerHTML = "&#128308; Record video"
			mediaRecorder.stop();
			setTimeout(() => {
				const blob = new Blob(recordedChunks, {
					// type: 'video/mp4'
					type: 'video/webm'
				});
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;
				a.download = "dexed_video.webm";
				a.click();
				URL.revokeObjectURL(url);
			}, 0);
		}
	});

	// navigator.serial.addEventListener('connect', (e) => {
	// 	// Connect to `e.target` or add it to a list of available ports.
	// 	console.log('connected')
	// });

	// navigator.serial.addEventListener('disconnect', (e) => {
	// 	// Remove `e.target` from the list of available ports.
	// 	console.log('disconnected')
	// });
}

function clear() {
	ctxVideo.fillStyle = "black";
	ctxVideo.fillRect(0, 0, canvas.width, canvas.height);
}
function readcolor(colh, coll) {
	col = colh*256+coll;
	b = (((col) & 0x001F) << 3) & 0xFF;
	g = (((col) & 0x07E0) >>> 3) & 0xFF;
	r = (((col) & 0xF800) >>> 8) & 0xFF;
	c = "rgb("+r+","+g+","+b+")";
	ctxVideo.fillStyle = c;
}
function readbgcolor(bgcolh, bgcoll) {
	bgcolor = bgcolh*256+bgcoll;
	b = (((bgcolor) & 0x001F) << 3) & 0xFF;
	g = (((bgcolor) & 0x07E0) >>> 3) & 0xFF;
	r = (((bgcolor) & 0xF800) >>> 8) & 0xFF;
	bgcolor = "rgb("+r+","+g+","+b+")";
}

// 5x7 font
const font = [
  0x00, 0x00, 0x00, 0x00, 0x00,//
  0x3E, 0x5B, 0x4F, 0x5B, 0x3E,//
  0x3E, 0x6B, 0x4F, 0x6B, 0x3E,//
  0x1C, 0x3E, 0x7C, 0x3E, 0x1C,//
  0x18, 0x3C, 0x7E, 0x3C, 0x18,//
  0x1C, 0x57, 0x7D, 0x57, 0x1C,//
  0x1C, 0x5E, 0x7F, 0x5E, 0x1C,//
  0x00, 0x18, 0x3C, 0x18, 0x00,//
  0xFF, 0xE7, 0xC3, 0xE7, 0xFF,//
  0x00, 0x18, 0x24, 0x18, 0x00,//
  0xFF, 0xE7, 0xDB, 0xE7, 0xFF,//
  0x30, 0x48, 0x3A, 0x06, 0x0E,//
  0x26, 0x29, 0x79, 0x29, 0x26,//
  0x40, 0x7F, 0x05, 0x05, 0x07,//
  0x40, 0x7F, 0x05, 0x25, 0x3F,//
  0x5A, 0x3C, 0xE7, 0x3C, 0x5A,//
  0x7F, 0x3E, 0x1C, 0x1C, 0x08,//
  0x08, 0x1C, 0x1C, 0x3E, 0x7F,//
  0x14, 0x22, 0x7F, 0x22, 0x14,//
  0x5F, 0x5F, 0x00, 0x5F, 0x5F,//
  0x06, 0x09, 0x7F, 0x01, 0x7F,//
  0x00, 0x66, 0x89, 0x95, 0x6A,//
  0x60, 0x60, 0x60, 0x60, 0x60,//
  0x94, 0xA2, 0xFF, 0xA2, 0x94,//
  0x08, 0x04, 0x7E, 0x04, 0x08,//
  0x10, 0x20, 0x7E, 0x20, 0x10,//
  0x08, 0x08, 0x2A, 0x1C, 0x08,//
  0x08, 0x1C, 0x2A, 0x08, 0x08,//
  0x1E, 0x10, 0x10, 0x10, 0x10,//
  0x0C, 0x1E, 0x0C, 0x1E, 0x0C,//
  0x30, 0x38, 0x3E, 0x38, 0x30,//
  0x06, 0x0E, 0x3E, 0x0E, 0x06,//
  0x00, 0x00, 0x00, 0x00, 0x00,//
  0x00, 0x00, 0x5F, 0x00, 0x00,// !
  0x00, 0x07, 0x00, 0x07, 0x00,// "
  0x14, 0x7F, 0x14, 0x7F, 0x14,// #
  0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
  0x23, 0x13, 0x08, 0x64, 0x62,// %
  0x36, 0x49, 0x55, 0x22, 0x50,// &
  0x00, 0x05, 0x03, 0x00, 0x00,// '
  0x00, 0x1C, 0x22, 0x41, 0x00,// (
  0x00, 0x41, 0x22, 0x1C, 0x00,// )
  0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
  0x08, 0x08, 0x3E, 0x08, 0x08,// +
  0x00, 0x50, 0x30, 0x00, 0x00,// ,
  0x08, 0x08, 0x08, 0x08, 0x08,// -
  0x00, 0x60, 0x60, 0x00, 0x00,// .
  0x20, 0x10, 0x08, 0x04, 0x02,// /
  0x7F, 0x51, 0x49, 0x45, 0x7F,// 0
  0x40, 0x41, 0x7F, 0x40, 0x40,// 1
  0x79, 0x49, 0x49, 0x49, 0x4F,// 2
  0x49, 0x49, 0x49, 0x49, 0x7F,// 3
  0x0F, 0x08, 0x08, 0x08, 0x7F,// 4
  0x4F, 0x49, 0x49, 0x49, 0x79,// 5
  0x7F, 0x49, 0x49, 0x49, 0x79,// 6
  0x01, 0x01, 0x71, 0x09, 0x07,// 7
  0x7F, 0x49, 0x49, 0x49, 0x7F,// 8
  0x0F, 0x09, 0x09, 0x09, 0x7F,// 9
  0x00, 0x36, 0x36, 0x00, 0x00,// :
  0x00, 0x56, 0x36, 0x00, 0x00,// ;
  0x00, 0x08, 0x14, 0x22, 0x41,// <
  0x14, 0x14, 0x14, 0x14, 0x14,// =
  0x41, 0x22, 0x14, 0x08, 0x00,// >
  0x02, 0x01, 0x51, 0x09, 0x06,// ?
  0x32, 0x49, 0x79, 0x41, 0x3E,// @  //64
  0x7E, 0x09, 0x09, 0x09, 0x7E,// A
  0x7F, 0x49, 0x49, 0x49, 0x36,// B
  0x3E, 0x41, 0x41, 0x41, 0x22,// C
  0x7F, 0x41, 0x41, 0x41, 0x3E,// D
  0x7F, 0x49, 0x49, 0x49, 0x41,// E
  0x7F, 0x09, 0x09, 0x01, 0x01,// F
  0x3E, 0x41, 0x41, 0x51, 0x32,// G
  0x7F, 0x08, 0x08, 0x08, 0x7F,// H
  0x41, 0x41, 0x7F, 0x41, 0x41,// I
  0x20, 0x40, 0x41, 0x3F, 0x01,// J
  0x7F, 0x08, 0x14, 0x22, 0x41,// K
  0x7F, 0x40, 0x40, 0x40, 0x40,// L
  0x7F, 0x02, 0x04, 0x02, 0x7F,// M
  0x7F, 0x02, 0x04, 0x08, 0x7F,// N
  0x3E, 0x41, 0x41, 0x41, 0x3E,// O
  0x7F, 0x09, 0x09, 0x09, 0x06,// P
  0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
  0x7F, 0x09, 0x09, 0x19, 0x66,// R
  0x46, 0x49, 0x49, 0x49, 0x31,// S
  0x01, 0x01, 0x7F, 0x01, 0x01,// T
  0x3F, 0x40, 0x40, 0x40, 0x3F,// U
  0x1F, 0x20, 0x40, 0x20, 0x1F,// V
  0x7F, 0x20, 0x18, 0x20, 0x7F,// W
  0x63, 0x14, 0x08, 0x14, 0x63,// X
  0x47, 0x48, 0x48, 0x48, 0x3F,// Y
  0x61, 0x51, 0x49, 0x45, 0x43,// Z
  0x00, 0x00, 0x7F, 0x41, 0x41,// [
  0x02, 0x04, 0x08, 0x10, 0x20,// "\"
  0x41, 0x41, 0x7F, 0x00, 0x00,// ]
  0x04, 0x02, 0x01, 0x02, 0x04,// ^
  0x40, 0x40, 0x40, 0x40, 0x40,// _
  0x00, 0x01, 0x02, 0x04, 0x00,// `
  0x38, 0x44, 0x44, 0x44, 0x7C,// a
  0x7E, 0x44, 0x44, 0x44, 0x38,// b
  0x38, 0x44, 0x44, 0x44, 0x44,// c
  0x38, 0x44, 0x44, 0x44, 0x7E,// d
  0x38, 0x54, 0x54, 0x54, 0x58,// e
  0x10, 0x7C, 0x12, 0x12, 0x12,// f
  0x1C, 0x54, 0x54, 0x54, 0x3C,// g
  0x7E, 0x04, 0x04, 0x04, 0x78,// h
  0x00, 0x44, 0x7D, 0x40, 0x00,// i
  0x20, 0x40, 0x44, 0x3D, 0x00,// j
  0x00, 0x7F, 0x10, 0x28, 0x44,// k
  0x3C, 0x40, 0x40, 0x40, 0x40,// l
  0x7C, 0x04, 0x78, 0x04, 0x7C,// m
  0x7C, 0x04, 0x04, 0x04, 0x78,// n
  0x38, 0x44, 0x44, 0x44, 0x38,// o
  0x7C, 0x24, 0x24, 0x24, 0x1C,// p
  0x38, 0x24, 0x24, 0x24, 0x7C,// q
  0x78, 0x04, 0x04, 0x04, 0x04,// r
  0x58, 0x54, 0x54, 0x54, 0x34,// s
  0x04, 0x3E, 0x44, 0x44, 0x44,// t
  0x3C, 0x40, 0x40, 0x40, 0x3C,// u
  0x1C, 0x20, 0x40, 0x20, 0x1C,// v
  0x3C, 0x40, 0x30, 0x40, 0x3C,// w
  0x44, 0x28, 0x10, 0x28, 0x44,// x
  0x4C, 0x50, 0x50, 0x50, 0x3C,// y
  0x44, 0x64, 0x54, 0x4C, 0x44,// z
  0x00, 0x08, 0x36, 0x41, 0x00,// {
  0x00, 0x00, 0x7F, 0x00, 0x00,// |
  0x00, 0x41, 0x36, 0x08, 0x00,// }
  0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
  0x08, 0x1C, 0x2A, 0x08, 0x08, // <-
  0x1E, 0xA1, 0xA1, 0x61, 0x12,
  0x3A, 0x40, 0x40, 0x20, 0x7A,
  0x38, 0x54, 0x54, 0x55, 0x59,
  0x21, 0x55, 0x55, 0x79, 0x41,
  0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
  0x21, 0x55, 0x54, 0x78, 0x40,
  0x20, 0x54, 0x55, 0x79, 0x40,
  0x0C, 0x1E, 0x52, 0x72, 0x12,
  0x40, 0x30, 0x0c, 0x02, 0x7F,  // BRAIDS Wave 1 SAW  // 0x39, 0x55, 0x55, 0x55, 0x59,  // note: grid is vertical slices
  0x10, 0x08, 0x04, 0x1e, 0x00,  // BRAIDS Centered SAW
  0x40, 0x20, 0x10, 0x08, 0x7C,  // BRAIDS BABY SAW
  0x60, 0x1C, 0x03, 0x1C, 0x60,  // BRAID TRIANGLE
  0x7f, 0x01, 0x01, 0x01, 0x7f,  // BRAIDS SQUARE
  0x78, 0x08, 0x08, 0x08, 0x78,  // BRAIDS BABY SQUARE
  0x40, 0x40, 0x7F, 0x01, 0x7F,  // BRAIDS PULSE  0x7D, 0x12, 0x11, 0x12, 0x7D A-umlaut 
  0xF0, 0x28, 0x25, 0x28, 0xF0,
  0x7C, 0x54, 0x55, 0x45, 0x00,
  0x20, 0x54, 0x54, 0x7C, 0x54,
  0x7C, 0x0A, 0x09, 0x7F, 0x49,
  0x32, 0x49, 0x49, 0x49, 0x32,
  0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
  0x32, 0x4A, 0x48, 0x48, 0x30,
  0x3A, 0x41, 0x41, 0x21, 0x7A,
  0x3A, 0x42, 0x40, 0x20, 0x78,
  0x00, 0x9D, 0xA0, 0xA0, 0x7D,
  0x3D, 0x42, 0x42, 0x42, 0x3D, // O-umlaut
  0x3D, 0x40, 0x40, 0x40, 0x3D,
  0x3C, 0x24, 0xFF, 0x24, 0x24,
  0x48, 0x7E, 0x49, 0x43, 0x66,
  0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
  0xFF, 0x09, 0x29, 0xF6, 0x20,
  0xC0, 0x88, 0x7E, 0x09, 0x03,
  0x20, 0x54, 0x54, 0x79, 0x41,
  0x00, 0x00, 0x44, 0x7D, 0x41,
  0x30, 0x48, 0x48, 0x4A, 0x32,
  0x38, 0x40, 0x40, 0x22, 0x7A,
  0x00, 0x7A, 0x0A, 0x0A, 0x72,
  0x7D, 0x0D, 0x19, 0x31, 0x7D,
  0x26, 0x29, 0x29, 0x2F, 0x28,
  0x26, 0x29, 0x29, 0x29, 0x26,
  0x30, 0x48, 0x4D, 0x40, 0x20,
  0x38, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x38,
  0x2F, 0x10, 0xC8, 0xAC, 0xBA,
  0x2F, 0x10, 0x28, 0x34, 0xFA,
  0x00, 0x00, 0x7B, 0x00, 0x00,
  0x08, 0x14, 0x2A, 0x14, 0x22,
  0x22, 0x14, 0x2A, 0x14, 0x08,
  0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old // code
  0xAA, 0x55, 0xAA, 0x55, 0xAA,  // 50% block
  0xFF, 0x55, 0xFF, 0x55, 0xFF,  // 75% block
  0x00, 0x00, 0x00, 0xFF, 0x00,
  0x10, 0x10, 0x10, 0xFF, 0x00,
  0x14, 0x14, 0x14, 0xFF, 0x00,
  0x10, 0x10, 0xFF, 0x00, 0xFF,
  0x10, 0x10, 0xF0, 0x10, 0xF0,
  0x14, 0x14, 0x14, 0xFC, 0x00,
  0x14, 0x14, 0xF7, 0x00, 0xFF,
  0x00, 0x00, 0xFF, 0x00, 0xFF,
  0x14, 0x14, 0xF4, 0x04, 0xFC,
  0x14, 0x14, 0x17, 0x10, 0x1F,
  0x10, 0x10, 0x1F, 0x10, 0x1F,
  0x14, 0x14, 0x14, 0x1F, 0x00,
  0x10, 0x10, 0x10, 0xF0, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0x10,
  0x10, 0x10, 0x10, 0x1F, 0x10,
  0x10, 0x10, 0x10, 0xF0, 0x10,
  0x00, 0x00, 0x00, 0xFF, 0x10,
  0x10, 0x10, 0x10, 0x10, 0x10,
  0x10, 0x10, 0x10, 0xFF, 0x10,
  0x00, 0x00, 0x00, 0xFF, 0x14,
  0x00, 0x00, 0xFF, 0x00, 0xFF,
  0x00, 0x00, 0x1F, 0x10, 0x17,
  0x00, 0x00, 0xFC, 0x04, 0xF4,
  0x14, 0x14, 0x17, 0x10, 0x17,
  0x14, 0x14, 0xF4, 0x04, 0xF4,
  0x00, 0x00, 0xFF, 0x00, 0xF7,
  0x14, 0x14, 0x14, 0x14, 0x14,
  0x14, 0x14, 0xF7, 0x00, 0xF7,
  0x14, 0x14, 0x14, 0x17, 0x14,
  0x10, 0x10, 0x1F, 0x10, 0x1F,
  0x14, 0x14, 0x14, 0xF4, 0x14,
  0x10, 0x10, 0xF0, 0x10, 0xF0,
  0x00, 0x00, 0x1F, 0x10, 0x1F,
  0x00, 0x00, 0x00, 0x1F, 0x14,
  0x00, 0x00, 0x00, 0xFC, 0x14,
  0x00, 0x00, 0xF0, 0x10, 0xF0,
  0x10, 0x10, 0xFF, 0x10, 0xFF,
  0x14, 0x14, 0x14, 0xFF, 0x14,
  0x10, 0x10, 0x10, 0x1F, 0x00,
  0x00, 0x00, 0x00, 0xF0, 0x10,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  0xFF, 0xFF, 0xFF, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xFF,
  0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
  0x38, 0x44, 0x44, 0x38, 0x44,
  0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
  0x7E, 0x02, 0x02, 0x06, 0x06,
  0x02, 0x7E, 0x02, 0x7E, 0x02,
  0x63, 0x55, 0x49, 0x41, 0x63,
  0x38, 0x44, 0x44, 0x3C, 0x04,
  0x40, 0x7E, 0x20, 0x1E, 0x20,
  0x06, 0x02, 0x7E, 0x02, 0x02,
  0x99, 0xA5, 0xE7, 0xA5, 0x99,
  0x1C, 0x2A, 0x49, 0x2A, 0x1C,
  0x4C, 0x72, 0x01, 0x72, 0x4C,
  0x30, 0x4A, 0x4D, 0x4D, 0x30,
  0x30, 0x48, 0x78, 0x48, 0x30,
  0xBC, 0x62, 0x5A, 0x46, 0x3D,
  0x3E, 0x49, 0x49, 0x49, 0x00,
  0x7E, 0x01, 0x01, 0x01, 0x7E,
  0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
  0x44, 0x44, 0x5F, 0x44, 0x44,
  0x40, 0x51, 0x4A, 0x44, 0x40,
  0x40, 0x44, 0x4A, 0x51, 0x40,
  0x00, 0x00, 0xFF, 0x01, 0x03,
  0xE0, 0x80, 0xFF, 0x00, 0x00,
  0x08, 0x08, 0x6B, 0x6B, 0x08,
  0x36, 0x12, 0x36, 0x24, 0x36,
  0x06, 0x0F, 0x09, 0x0F, 0x06,
  0x00, 0x00, 0x18, 0x18, 0x00,
  0x00, 0x00, 0x10, 0x10, 0x00,
  0x30, 0x40, 0xFF, 0x01, 0x01,
  0x00, 0x1F, 0x01, 0x01, 0x1E,
  0x00, 0x19, 0x1D, 0x17, 0x12,
  0x00, 0x3C, 0x3C, 0x3C, 0x3C,
  0x00, 0x00, 0x00, 0x00, 0x00 // #255 NBSP
  ];

function bitRead(b, bitPos) {
	const x = b & (1 << bitPos);
	return x == 0 ? 0 : 1;
}

function drawChar(x, y, ch, col, bg, size) {
	for (let i = 0; i < 5; i++) { // Char bitmap = 5 columns

		let line = font[ch*5+i];
		for (let j = 0; j < 8; j++, line >>= 1) {
			if ( bitRead(line, 0) == 1  ) {
				ctxVideo.fillStyle = c;
				if (size == 1 ) {
					// ctxVideo.fillRect((x + i)*2, (y + j)*2, 2, 2);
					ctxVideo.fillRect((x + i), (y + j), 1, 1);
				} else {
					// ctxVideo.fillRect(x*2+i*4, y*2 + j*4, 4, 4);
					ctxVideo.fillRect(x*1+i*2, y + j*2, 2, 2);
				}
			}
			else if ( bitRead(line, 0) == 0 && bg != col ) {
				ctxVideo.fillStyle = bgcolor;
				if (size == 1 ) {
					// ctxVideo.fillRect((x + i)*2, (y + j)*2, 2, 2);
					ctxVideo.fillRect((x + i), (y + j), 1, 1);
				} else {
					// ctxVideo.fillRect(x*2+i*4, y*2 + j*4, 4, 4);
					ctxVideo.fillRect(x+i*2, y + j*2, 2, 2);
				}
			}
		}
	}

	if (bg != col) { // If opaque, draw vertical line for last column
		ctxVideo.fillStyle = bgcolor;
		if (size == 1 )
			ctxVideo.fillRect((x + 5)*2, y *2, 2, 16);
		else
			ctxVideo.fillRect(x*2 + 5*4, y *2, 4, 32);
	}
}

const FRAME_START = 99;
const FRAME_END = 88;

function process(data) {
    for (let i = 0; i < data.length; i++) {
		const b = data[i];

		switch (b) {
			case FRAME_END:
				const cmd = _buffer[1];
				switch(cmd) {
					case 90:
						_frameLength = 8;
						break;
					case 91:
					case 92:
						_frameLength = 10;
						break;
					case 93:
						_frameLength = 4;
						break;
					case 94:
					case 95:
						_frameLength = 12;
						break;
					default:
						_frameLength = -1;
						break;
				}

				// end of frame ?
				if(_i === _frameLength && _buffer[0] === FRAME_START) {
					_processFrame(_buffer.subarray(1, _i));
					_i = 0;
				} else {
					_buffer[_i++] = b;
				}
				break;

			default:
				_buffer[_i++] = b;
				break;
		}

    }
}

function _processFrame(frame) {
	switch(frame[0]) {
		case 90: // draw pixel
			x = frame[1]*256 + frame[2];
			y = frame[3]*256 + frame[4];
			readcolor(frame[5], frame[6]);
			// ctxVideo.fillRect(x*2, y*2, 2, 2);
			ctxVideo.fillRect(x, y, 1, 1);
			break;

		case 91: // draw vline
			x = frame[1]*256 + frame[2];
			y = frame[3]*256 + frame[4];
			h = frame[5]*256 + frame[6];
			readcolor(frame[7], frame[8]);
			// ctxVideo.fillRect(x*2, y*2, 2, h*2);
			ctxVideo.fillRect(x, y, 1, h);
			break;

		case 92: // draw hline
			x = frame[1]*256 + frame[2];
			y = frame[3]*256 + frame[4];
			w = frame[5]*256 + frame[6];
			readcolor(frame[7], frame[8]);
			// ctxVideo.fillRect(x*2, y*2, w*2, 2);
			ctxVideo.fillRect(x, y, w, 1);
			break;

		case 93: // fill screen
			readcolor(frame[1], frame[2]);
			ctxVideo.fillRect(0, 0, 320, 320);
			break;

		case 94: // fill rect
			x = frame[1]*256 + frame[2];
			y = frame[3]*256 + frame[4];
			w = frame[5]*256 + frame[6];
			h = frame[7]*256 + frame[8];
			readcolor(frame[9], frame[10]);
			// ctxVideo.fillRect(x*2, y*2, w*2, h*2);
			ctxVideo.fillRect(x, y, w, h);
			break;

		case 95: // draw char
			x = frame[1]*256 + frame[2];
			y = frame[3]*256 + frame[4];
			readcolor(frame[5], frame[6]);
			readbgcolor(frame[7], frame[8]);
			ch = frame[9];
			size = frame[10];
			drawChar(x, y, ch, c, bgcolor, size);
			break;

		default:
			console.error('command not supported', cmd);
			break;
	}
}
</script>
<script type="module">
	// Enable WebMidi.js and trigger the onEnabled() function when ready
	WebMidi
	  .enable()
	  .then(onEnabled)
	  .catch(err => alert(err));
  
	// Function triggered when WebMidi.js is ready
	async function onEnabled() {
		console.log('WebMidi enabled')
		let sequencerStarted = false;
   
		if (WebMidi.inputs.length < 1) {
    		document.body.innerHTML+= "No device detected.";
  		} else {
			// 	WebMidi.inputs.forEach((device, index) => {
			//  		document.body.innerHTML+= `${index}: ${device.name} <br>`;
			// 	});
	
		//   const mySynth = WebMidi.inputs[0];
			const mySynthInput = WebMidi.getInputByName("MicroDexed")
			const mySynthOutput = WebMidi.getOutputByName("MicroDexed")

			const dexed1 = mySynthOutput.channels[6];

			// for (let i = 0; i < 10; i++) {
			// 	dexed1.sendNoteOn("C3");
			// 	await sleep(500);
			// 	dexed1.sendNoteOff("C3");
			// }

			const btnSequencer = document.querySelector('#btnSequencer');

			btnSequencer.addEventListener('click', async () => {
				if(!sequencerStarted) {
					sequencerStarted = true;
					btnSequencer.textContent = 'Stop sequencer'
					mySynthOutput.sendStart();
				} else {
					sequencerStarted = false;
					btnSequencer.textContent = 'Start sequencer'
					mySynthOutput.sendStop();
				}
			});

			mySynthInput.addListener("start", e => {
				sequencerStarted = true;
				btnSequencer.textContent = 'Stop sequencer'
			});
			mySynthInput.addListener("stop", e => {
				sequencerStarted = false;
				btnSequencer.textContent = 'Start sequencer'
			});
	  	}
	}
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
  </script>
  <script type="module">
	// Audio
	let ctxAudio;
	let audioEnabled = false;
	// window.addEventListener('load', initAudio, false);

async function startAudio(attempts = 1) {
    if (ctxAudio || !audioEnabled)
        return;

    try {
		const optionsAudioCtx = {
			latencyHint : 'interactive'
		}
		ctxAudio = new AudioContext(optionsAudioCtx);
        await navigator.mediaDevices.getUserMedia({ audio: true });

        let deviceId;
        while (true) {
            deviceId = await findDeviceId();
            if (deviceId)
                break;

            if (--attempts > 0) {
                await wait(300);
            } else {
                break;
            }
        }

        if (!deviceId)
            throw new Error('MD not found');
console.log('deviceId', deviceId)

        streamAudio = await navigator.mediaDevices
            .getUserMedia({ audio: {
                deviceId: { exact: deviceId },
                autoGainControl: false,
                echoCancellation: false,
                noiseSuppression: false
            } })

        const source = ctxAudio.createMediaStreamSource(streamAudio);
        source.connect(ctxAudio.destination);

        if (ctxAudio.state !== 'running') {
			ctxAudio && ctxAudio.resume();
            // waitForUserGesture();
	    }

		let recording = false;
		let mediaRecorder;
		let recordedChunks;

		btnRecordAudio.addEventListener("click", () => {
			recording = !recording;
			if(recording) {
				btnRecordAudio.innerHTML = "&#11035; Stop";
				const optionsAudioMedia = {
       				// audioBitsPerSecond: 128000,
        			// videoBitsPerSecond: 2500000,
        			// mimeType: 'audio/ogg; codecs=opus'
				};
				mediaRecorder = new MediaRecorder(streamAudio, optionsAudioMedia);
				recordedChunks = [];
				mediaRecorder.ondataavailable = e => {
					if(e.data.size > 0){
						recordedChunks.push(e.data);
					}
				};
				mediaRecorder.start();
			} else {
				btnRecordAudio.innerHTML = "&#127908; Record audio"
				mediaRecorder.stop();
				setTimeout(() => {
					const blob = new Blob(recordedChunks, {
						type: "audio/ogg; codecs=opus"
					});
					const url = URL.createObjectURL(blob);
					const a = document.createElement("a");
					a.href = url;
					a.download = "dexed_audio.webm";
					a.click();
					URL.revokeObjectURL(url);
				}, 0);
			}
		});
    } catch (err) {
	    alert('Web Audio API is not supported in this browser');
        console.error(err);
        stopAudio();
    }

    if (!audioEnabled) {
        stopAudio();
    }
}

btnAudio.addEventListener('click', async () => {
	if (!ctxAudio) {
		enable();
		btnAudio.textContent = 'Stop audio'
		//startAudio(10);
	} else {
		btnAudio.textContent = 'Start audio'
		disable();
	}
});

async function findDeviceId() {
    const devices = await navigator.mediaDevices.enumerateDevices();
console.log(devices)
    return devices
        .filter(d =>
            d.kind === 'audioinput' &&
            /MicroDexed/.test(d.label) &&
            d.deviceId !== 'default' &&
            d.deviceId !== 'communications')
        .map(d => d.deviceId)[0];
}

async function stopAudio() {
    ctxAudio && await ctxAudio.close().catch(() => {});
    ctxAudio = null;
}

function waitForUserGesture() {
    const events = ['keydown', 'mousedown', 'touchstart'];

    function resume() {
        ctxAudio && ctxAudio.resume();
        events.forEach(e => {
            off(document, e, resume)
		});
    }

    events.forEach(e => {
        on(document, e, resume);
	});
}

function enable() {
    if (audioEnabled)
        return;

	audioEnabled = true;
    startAudio();
}
function disable() {
    audioEnabled = false;
    stopAudio();
}
function on(target, eventType, action, useCapture) {
    if (typeof target === 'string') {
        target = document.querySelectorAll(target);
    } else if (!(target instanceof Array)) {
        target = [target];
    }

    for (const element of target) {
        element.addEventListener(eventType, action, useCapture);
    }
}
function off(target, eventType, action, useCapture) {
    target.removeEventListener(eventType, action, useCapture);
}
function wait(time) {
    return new Promise(resolve => setTimeout(resolve, time));
}

</script>
  </body>
</html>